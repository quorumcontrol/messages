// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: services/services.proto

package services

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	signatures "github.com/quorumcontrol/messages/build/go/signatures"
	transactions "github.com/quorumcontrol/messages/build/go/transactions"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// This is the message we currently refer to as "Transaction" at the tupelo level
type AddBlockRequest struct {
	ObjectId    []byte   `protobuf:"bytes,1,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	PreviousTip []byte   `protobuf:"bytes,2,opt,name=previous_tip,json=previousTip,proto3" json:"previous_tip,omitempty"`
	Height      uint64   `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	NewTip      []byte   `protobuf:"bytes,4,opt,name=new_tip,json=newTip,proto3" json:"new_tip,omitempty"`
	Payload     []byte   `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
	State       [][]byte `protobuf:"bytes,6,rep,name=state,proto3" json:"state,omitempty"`
}

func (m *AddBlockRequest) Reset()         { *m = AddBlockRequest{} }
func (m *AddBlockRequest) String() string { return proto.CompactTextString(m) }
func (*AddBlockRequest) ProtoMessage()    {}
func (*AddBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{0}
}
func (m *AddBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddBlockRequest.Merge(m, src)
}
func (m *AddBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddBlockRequest proto.InternalMessageInfo

func (m *AddBlockRequest) GetObjectId() []byte {
	if m != nil {
		return m.ObjectId
	}
	return nil
}

func (m *AddBlockRequest) GetPreviousTip() []byte {
	if m != nil {
		return m.PreviousTip
	}
	return nil
}

func (m *AddBlockRequest) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *AddBlockRequest) GetNewTip() []byte {
	if m != nil {
		return m.NewTip
	}
	return nil
}

func (m *AddBlockRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *AddBlockRequest) GetState() [][]byte {
	if m != nil {
		return m.State
	}
	return nil
}

type ReceiveCurrentStateSnapshot struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *ReceiveCurrentStateSnapshot) Reset()         { *m = ReceiveCurrentStateSnapshot{} }
func (m *ReceiveCurrentStateSnapshot) String() string { return proto.CompactTextString(m) }
func (*ReceiveCurrentStateSnapshot) ProtoMessage()    {}
func (*ReceiveCurrentStateSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{1}
}
func (m *ReceiveCurrentStateSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveCurrentStateSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveCurrentStateSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveCurrentStateSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveCurrentStateSnapshot.Merge(m, src)
}
func (m *ReceiveCurrentStateSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveCurrentStateSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveCurrentStateSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveCurrentStateSnapshot proto.InternalMessageInfo

func (m *ReceiveCurrentStateSnapshot) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type RequestCurrentStateSnapshot struct {
}

func (m *RequestCurrentStateSnapshot) Reset()         { *m = RequestCurrentStateSnapshot{} }
func (m *RequestCurrentStateSnapshot) String() string { return proto.CompactTextString(m) }
func (*RequestCurrentStateSnapshot) ProtoMessage()    {}
func (*RequestCurrentStateSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{2}
}
func (m *RequestCurrentStateSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestCurrentStateSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestCurrentStateSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestCurrentStateSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestCurrentStateSnapshot.Merge(m, src)
}
func (m *RequestCurrentStateSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *RequestCurrentStateSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestCurrentStateSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_RequestCurrentStateSnapshot proto.InternalMessageInfo

type Ping struct {
	Msg string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *Ping) Reset()         { *m = Ping{} }
func (m *Ping) String() string { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()    {}
func (*Ping) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{3}
}
func (m *Ping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ping.Merge(m, src)
}
func (m *Ping) XXX_Size() int {
	return m.Size()
}
func (m *Ping) XXX_DiscardUnknown() {
	xxx_messageInfo_Ping.DiscardUnknown(m)
}

var xxx_messageInfo_Ping proto.InternalMessageInfo

func (m *Ping) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type Pong struct {
	Msg string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *Pong) Reset()         { *m = Pong{} }
func (m *Pong) String() string { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()    {}
func (*Pong) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{4}
}
func (m *Pong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pong.Merge(m, src)
}
func (m *Pong) XXX_Size() int {
	return m.Size()
}
func (m *Pong) XXX_DiscardUnknown() {
	xxx_messageInfo_Pong.DiscardUnknown(m)
}

var xxx_messageInfo_Pong proto.InternalMessageInfo

func (m *Pong) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type Credentials struct {
	WalletName string `protobuf:"bytes,1,opt,name=wallet_name,json=walletName,proto3" json:"wallet_name,omitempty"`
	PassPhrase string `protobuf:"bytes,2,opt,name=pass_phrase,json=passPhrase,proto3" json:"pass_phrase,omitempty"`
}

func (m *Credentials) Reset()         { *m = Credentials{} }
func (m *Credentials) String() string { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()    {}
func (*Credentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{5}
}
func (m *Credentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Credentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Credentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Credentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Credentials.Merge(m, src)
}
func (m *Credentials) XXX_Size() int {
	return m.Size()
}
func (m *Credentials) XXX_DiscardUnknown() {
	xxx_messageInfo_Credentials.DiscardUnknown(m)
}

var xxx_messageInfo_Credentials proto.InternalMessageInfo

func (m *Credentials) GetWalletName() string {
	if m != nil {
		return m.WalletName
	}
	return ""
}

func (m *Credentials) GetPassPhrase() string {
	if m != nil {
		return m.PassPhrase
	}
	return ""
}

type SerializableChainTree struct {
	Dag        [][]byte                         `protobuf:"bytes,1,rep,name=dag,proto3" json:"dag,omitempty"`
	Signatures map[string]*signatures.Signature `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// tip is a string because of compatability with the javascript layer
	// which cannot seem to parse a golang cid.Bytes()
	Tip string `protobuf:"bytes,3,opt,name=tip,proto3" json:"tip,omitempty"`
}

func (m *SerializableChainTree) Reset()         { *m = SerializableChainTree{} }
func (m *SerializableChainTree) String() string { return proto.CompactTextString(m) }
func (*SerializableChainTree) ProtoMessage()    {}
func (*SerializableChainTree) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{6}
}
func (m *SerializableChainTree) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SerializableChainTree) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SerializableChainTree.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SerializableChainTree) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SerializableChainTree.Merge(m, src)
}
func (m *SerializableChainTree) XXX_Size() int {
	return m.Size()
}
func (m *SerializableChainTree) XXX_DiscardUnknown() {
	xxx_messageInfo_SerializableChainTree.DiscardUnknown(m)
}

var xxx_messageInfo_SerializableChainTree proto.InternalMessageInfo

func (m *SerializableChainTree) GetDag() [][]byte {
	if m != nil {
		return m.Dag
	}
	return nil
}

func (m *SerializableChainTree) GetSignatures() map[string]*signatures.Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *SerializableChainTree) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

type RegisterWalletRequest struct {
	Creds *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
}

func (m *RegisterWalletRequest) Reset()         { *m = RegisterWalletRequest{} }
func (m *RegisterWalletRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterWalletRequest) ProtoMessage()    {}
func (*RegisterWalletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{7}
}
func (m *RegisterWalletRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterWalletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterWalletRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterWalletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterWalletRequest.Merge(m, src)
}
func (m *RegisterWalletRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterWalletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterWalletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterWalletRequest proto.InternalMessageInfo

func (m *RegisterWalletRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

type RegisterWalletResponse struct {
	WalletName string `protobuf:"bytes,1,opt,name=wallet_name,json=walletName,proto3" json:"wallet_name,omitempty"`
}

func (m *RegisterWalletResponse) Reset()         { *m = RegisterWalletResponse{} }
func (m *RegisterWalletResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterWalletResponse) ProtoMessage()    {}
func (*RegisterWalletResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{8}
}
func (m *RegisterWalletResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterWalletResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterWalletResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterWalletResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterWalletResponse.Merge(m, src)
}
func (m *RegisterWalletResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegisterWalletResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterWalletResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterWalletResponse proto.InternalMessageInfo

func (m *RegisterWalletResponse) GetWalletName() string {
	if m != nil {
		return m.WalletName
	}
	return ""
}

type StorageAdapterConfigForBadger struct {
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *StorageAdapterConfigForBadger) Reset()         { *m = StorageAdapterConfigForBadger{} }
func (m *StorageAdapterConfigForBadger) String() string { return proto.CompactTextString(m) }
func (*StorageAdapterConfigForBadger) ProtoMessage()    {}
func (*StorageAdapterConfigForBadger) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{9}
}
func (m *StorageAdapterConfigForBadger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageAdapterConfigForBadger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageAdapterConfigForBadger.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageAdapterConfigForBadger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageAdapterConfigForBadger.Merge(m, src)
}
func (m *StorageAdapterConfigForBadger) XXX_Size() int {
	return m.Size()
}
func (m *StorageAdapterConfigForBadger) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageAdapterConfigForBadger.DiscardUnknown(m)
}

var xxx_messageInfo_StorageAdapterConfigForBadger proto.InternalMessageInfo

func (m *StorageAdapterConfigForBadger) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type StorageAdapterConfigForIpld struct {
	Path    string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Offline bool   `protobuf:"varint,3,opt,name=offline,proto3" json:"offline,omitempty"`
}

func (m *StorageAdapterConfigForIpld) Reset()         { *m = StorageAdapterConfigForIpld{} }
func (m *StorageAdapterConfigForIpld) String() string { return proto.CompactTextString(m) }
func (*StorageAdapterConfigForIpld) ProtoMessage()    {}
func (*StorageAdapterConfigForIpld) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{10}
}
func (m *StorageAdapterConfigForIpld) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageAdapterConfigForIpld) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageAdapterConfigForIpld.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageAdapterConfigForIpld) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageAdapterConfigForIpld.Merge(m, src)
}
func (m *StorageAdapterConfigForIpld) XXX_Size() int {
	return m.Size()
}
func (m *StorageAdapterConfigForIpld) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageAdapterConfigForIpld.DiscardUnknown(m)
}

var xxx_messageInfo_StorageAdapterConfigForIpld proto.InternalMessageInfo

func (m *StorageAdapterConfigForIpld) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *StorageAdapterConfigForIpld) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *StorageAdapterConfigForIpld) GetOffline() bool {
	if m != nil {
		return m.Offline
	}
	return false
}

type StorageAdapterConfig struct {
	// Types that are valid to be assigned to AdapterConfig:
	//	*StorageAdapterConfig_Badger
	//	*StorageAdapterConfig_Ipld
	AdapterConfig isStorageAdapterConfig_AdapterConfig `protobuf_oneof:"adapter_config"`
}

func (m *StorageAdapterConfig) Reset()         { *m = StorageAdapterConfig{} }
func (m *StorageAdapterConfig) String() string { return proto.CompactTextString(m) }
func (*StorageAdapterConfig) ProtoMessage()    {}
func (*StorageAdapterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{11}
}
func (m *StorageAdapterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageAdapterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageAdapterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageAdapterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageAdapterConfig.Merge(m, src)
}
func (m *StorageAdapterConfig) XXX_Size() int {
	return m.Size()
}
func (m *StorageAdapterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageAdapterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StorageAdapterConfig proto.InternalMessageInfo

type isStorageAdapterConfig_AdapterConfig interface {
	isStorageAdapterConfig_AdapterConfig()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageAdapterConfig_Badger struct {
	Badger *StorageAdapterConfigForBadger `protobuf:"bytes,1,opt,name=badger,proto3,oneof"`
}
type StorageAdapterConfig_Ipld struct {
	Ipld *StorageAdapterConfigForIpld `protobuf:"bytes,2,opt,name=ipld,proto3,oneof"`
}

func (*StorageAdapterConfig_Badger) isStorageAdapterConfig_AdapterConfig() {}
func (*StorageAdapterConfig_Ipld) isStorageAdapterConfig_AdapterConfig()   {}

func (m *StorageAdapterConfig) GetAdapterConfig() isStorageAdapterConfig_AdapterConfig {
	if m != nil {
		return m.AdapterConfig
	}
	return nil
}

func (m *StorageAdapterConfig) GetBadger() *StorageAdapterConfigForBadger {
	if x, ok := m.GetAdapterConfig().(*StorageAdapterConfig_Badger); ok {
		return x.Badger
	}
	return nil
}

func (m *StorageAdapterConfig) GetIpld() *StorageAdapterConfigForIpld {
	if x, ok := m.GetAdapterConfig().(*StorageAdapterConfig_Ipld); ok {
		return x.Ipld
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StorageAdapterConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StorageAdapterConfig_Badger)(nil),
		(*StorageAdapterConfig_Ipld)(nil),
	}
}

type GenerateChainRequest struct {
	Creds          *Credentials          `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	KeyAddr        string                `protobuf:"bytes,2,opt,name=key_addr,json=keyAddr,proto3" json:"key_addr,omitempty"`
	StorageAdapter *StorageAdapterConfig `protobuf:"bytes,3,opt,name=storage_adapter,json=storageAdapter,proto3" json:"storage_adapter,omitempty"`
}

func (m *GenerateChainRequest) Reset()         { *m = GenerateChainRequest{} }
func (m *GenerateChainRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateChainRequest) ProtoMessage()    {}
func (*GenerateChainRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{12}
}
func (m *GenerateChainRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateChainRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateChainRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateChainRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateChainRequest.Merge(m, src)
}
func (m *GenerateChainRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateChainRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateChainRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateChainRequest proto.InternalMessageInfo

func (m *GenerateChainRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *GenerateChainRequest) GetKeyAddr() string {
	if m != nil {
		return m.KeyAddr
	}
	return ""
}

func (m *GenerateChainRequest) GetStorageAdapter() *StorageAdapterConfig {
	if m != nil {
		return m.StorageAdapter
	}
	return nil
}

type GenerateChainResponse struct {
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *GenerateChainResponse) Reset()         { *m = GenerateChainResponse{} }
func (m *GenerateChainResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateChainResponse) ProtoMessage()    {}
func (*GenerateChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{13}
}
func (m *GenerateChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateChainResponse.Merge(m, src)
}
func (m *GenerateChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateChainResponse proto.InternalMessageInfo

func (m *GenerateChainResponse) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type ExportChainRequest struct {
	Creds   *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId string       `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *ExportChainRequest) Reset()         { *m = ExportChainRequest{} }
func (m *ExportChainRequest) String() string { return proto.CompactTextString(m) }
func (*ExportChainRequest) ProtoMessage()    {}
func (*ExportChainRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{14}
}
func (m *ExportChainRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportChainRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportChainRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportChainRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportChainRequest.Merge(m, src)
}
func (m *ExportChainRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExportChainRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportChainRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExportChainRequest proto.InternalMessageInfo

func (m *ExportChainRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *ExportChainRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type ExportChainResponse struct {
	ChainTree string `protobuf:"bytes,1,opt,name=chain_tree,json=chainTree,proto3" json:"chain_tree,omitempty"`
}

func (m *ExportChainResponse) Reset()         { *m = ExportChainResponse{} }
func (m *ExportChainResponse) String() string { return proto.CompactTextString(m) }
func (*ExportChainResponse) ProtoMessage()    {}
func (*ExportChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{15}
}
func (m *ExportChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportChainResponse.Merge(m, src)
}
func (m *ExportChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExportChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExportChainResponse proto.InternalMessageInfo

func (m *ExportChainResponse) GetChainTree() string {
	if m != nil {
		return m.ChainTree
	}
	return ""
}

type ImportChainRequest struct {
	Creds *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	// index 2 is a deleted key, intentionally omitted
	ChainTree      string                `protobuf:"bytes,3,opt,name=chain_tree,json=chainTree,proto3" json:"chain_tree,omitempty"`
	StorageAdapter *StorageAdapterConfig `protobuf:"bytes,4,opt,name=storage_adapter,json=storageAdapter,proto3" json:"storage_adapter,omitempty"`
	SkipValidation bool                  `protobuf:"varint,5,opt,name=skip_validation,json=skipValidation,proto3" json:"skip_validation,omitempty"`
}

func (m *ImportChainRequest) Reset()         { *m = ImportChainRequest{} }
func (m *ImportChainRequest) String() string { return proto.CompactTextString(m) }
func (*ImportChainRequest) ProtoMessage()    {}
func (*ImportChainRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{16}
}
func (m *ImportChainRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportChainRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportChainRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportChainRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportChainRequest.Merge(m, src)
}
func (m *ImportChainRequest) XXX_Size() int {
	return m.Size()
}
func (m *ImportChainRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportChainRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImportChainRequest proto.InternalMessageInfo

func (m *ImportChainRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *ImportChainRequest) GetChainTree() string {
	if m != nil {
		return m.ChainTree
	}
	return ""
}

func (m *ImportChainRequest) GetStorageAdapter() *StorageAdapterConfig {
	if m != nil {
		return m.StorageAdapter
	}
	return nil
}

func (m *ImportChainRequest) GetSkipValidation() bool {
	if m != nil {
		return m.SkipValidation
	}
	return false
}

type ImportChainResponse struct {
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *ImportChainResponse) Reset()         { *m = ImportChainResponse{} }
func (m *ImportChainResponse) String() string { return proto.CompactTextString(m) }
func (*ImportChainResponse) ProtoMessage()    {}
func (*ImportChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{17}
}
func (m *ImportChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportChainResponse.Merge(m, src)
}
func (m *ImportChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *ImportChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ImportChainResponse proto.InternalMessageInfo

func (m *ImportChainResponse) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type GenerateKeyRequest struct {
	Creds *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
}

func (m *GenerateKeyRequest) Reset()         { *m = GenerateKeyRequest{} }
func (m *GenerateKeyRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateKeyRequest) ProtoMessage()    {}
func (*GenerateKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{18}
}
func (m *GenerateKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateKeyRequest.Merge(m, src)
}
func (m *GenerateKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateKeyRequest proto.InternalMessageInfo

func (m *GenerateKeyRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

type GenerateKeyResponse struct {
	KeyAddr string `protobuf:"bytes,1,opt,name=key_addr,json=keyAddr,proto3" json:"key_addr,omitempty"`
}

func (m *GenerateKeyResponse) Reset()         { *m = GenerateKeyResponse{} }
func (m *GenerateKeyResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateKeyResponse) ProtoMessage()    {}
func (*GenerateKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{19}
}
func (m *GenerateKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateKeyResponse.Merge(m, src)
}
func (m *GenerateKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateKeyResponse proto.InternalMessageInfo

func (m *GenerateKeyResponse) GetKeyAddr() string {
	if m != nil {
		return m.KeyAddr
	}
	return ""
}

type GetTipRequest struct {
	Creds   *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId string       `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *GetTipRequest) Reset()         { *m = GetTipRequest{} }
func (m *GetTipRequest) String() string { return proto.CompactTextString(m) }
func (*GetTipRequest) ProtoMessage()    {}
func (*GetTipRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{20}
}
func (m *GetTipRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTipRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTipRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTipRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTipRequest.Merge(m, src)
}
func (m *GetTipRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTipRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTipRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTipRequest proto.InternalMessageInfo

func (m *GetTipRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *GetTipRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type GetTipResponse struct {
	Tip string `protobuf:"bytes,1,opt,name=tip,proto3" json:"tip,omitempty"`
}

func (m *GetTipResponse) Reset()         { *m = GetTipResponse{} }
func (m *GetTipResponse) String() string { return proto.CompactTextString(m) }
func (*GetTipResponse) ProtoMessage()    {}
func (*GetTipResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{21}
}
func (m *GetTipResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTipResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTipResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTipResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTipResponse.Merge(m, src)
}
func (m *GetTipResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTipResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTipResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTipResponse proto.InternalMessageInfo

func (m *GetTipResponse) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

type ListChainIdsRequest struct {
	Creds *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
}

func (m *ListChainIdsRequest) Reset()         { *m = ListChainIdsRequest{} }
func (m *ListChainIdsRequest) String() string { return proto.CompactTextString(m) }
func (*ListChainIdsRequest) ProtoMessage()    {}
func (*ListChainIdsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{22}
}
func (m *ListChainIdsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListChainIdsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListChainIdsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListChainIdsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListChainIdsRequest.Merge(m, src)
}
func (m *ListChainIdsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListChainIdsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListChainIdsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListChainIdsRequest proto.InternalMessageInfo

func (m *ListChainIdsRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

type ListChainIdsResponse struct {
	ChainIds []string `protobuf:"bytes,1,rep,name=chain_ids,json=chainIds,proto3" json:"chain_ids,omitempty"`
}

func (m *ListChainIdsResponse) Reset()         { *m = ListChainIdsResponse{} }
func (m *ListChainIdsResponse) String() string { return proto.CompactTextString(m) }
func (*ListChainIdsResponse) ProtoMessage()    {}
func (*ListChainIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{23}
}
func (m *ListChainIdsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListChainIdsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListChainIdsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListChainIdsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListChainIdsResponse.Merge(m, src)
}
func (m *ListChainIdsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListChainIdsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListChainIdsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListChainIdsResponse proto.InternalMessageInfo

func (m *ListChainIdsResponse) GetChainIds() []string {
	if m != nil {
		return m.ChainIds
	}
	return nil
}

type ListKeysRequest struct {
	Creds *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
}

func (m *ListKeysRequest) Reset()         { *m = ListKeysRequest{} }
func (m *ListKeysRequest) String() string { return proto.CompactTextString(m) }
func (*ListKeysRequest) ProtoMessage()    {}
func (*ListKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{24}
}
func (m *ListKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKeysRequest.Merge(m, src)
}
func (m *ListKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListKeysRequest proto.InternalMessageInfo

func (m *ListKeysRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

type ListKeysResponse struct {
	KeyAddrs []string `protobuf:"bytes,1,rep,name=key_addrs,json=keyAddrs,proto3" json:"key_addrs,omitempty"`
}

func (m *ListKeysResponse) Reset()         { *m = ListKeysResponse{} }
func (m *ListKeysResponse) String() string { return proto.CompactTextString(m) }
func (*ListKeysResponse) ProtoMessage()    {}
func (*ListKeysResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{25}
}
func (m *ListKeysResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKeysResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListKeysResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListKeysResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKeysResponse.Merge(m, src)
}
func (m *ListKeysResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListKeysResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKeysResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListKeysResponse proto.InternalMessageInfo

func (m *ListKeysResponse) GetKeyAddrs() []string {
	if m != nil {
		return m.KeyAddrs
	}
	return nil
}

type SetOwnerRequest struct {
	Creds   *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId string       `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	KeyAddr string       `protobuf:"bytes,3,opt,name=key_addr,json=keyAddr,proto3" json:"key_addr,omitempty"`
	// index 4 is a deleted key and intentionally omitted
	Payload *transactions.SetOwnershipPayload `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SetOwnerRequest) Reset()         { *m = SetOwnerRequest{} }
func (m *SetOwnerRequest) String() string { return proto.CompactTextString(m) }
func (*SetOwnerRequest) ProtoMessage()    {}
func (*SetOwnerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{26}
}
func (m *SetOwnerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetOwnerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetOwnerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetOwnerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetOwnerRequest.Merge(m, src)
}
func (m *SetOwnerRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetOwnerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetOwnerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetOwnerRequest proto.InternalMessageInfo

func (m *SetOwnerRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *SetOwnerRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *SetOwnerRequest) GetKeyAddr() string {
	if m != nil {
		return m.KeyAddr
	}
	return ""
}

func (m *SetOwnerRequest) GetPayload() *transactions.SetOwnershipPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type SetOwnerResponse struct {
	Tip string `protobuf:"bytes,1,opt,name=tip,proto3" json:"tip,omitempty"`
}

func (m *SetOwnerResponse) Reset()         { *m = SetOwnerResponse{} }
func (m *SetOwnerResponse) String() string { return proto.CompactTextString(m) }
func (*SetOwnerResponse) ProtoMessage()    {}
func (*SetOwnerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{27}
}
func (m *SetOwnerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetOwnerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetOwnerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetOwnerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetOwnerResponse.Merge(m, src)
}
func (m *SetOwnerResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetOwnerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetOwnerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetOwnerResponse proto.InternalMessageInfo

func (m *SetOwnerResponse) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

type SetDataRequest struct {
	Creds   *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId string       `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	KeyAddr string       `protobuf:"bytes,3,opt,name=key_addr,json=keyAddr,proto3" json:"key_addr,omitempty"`
	// indexes 4 and 5 are deleted keys and intentionally omitted
	Payload *transactions.SetDataPayload `protobuf:"bytes,6,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SetDataRequest) Reset()         { *m = SetDataRequest{} }
func (m *SetDataRequest) String() string { return proto.CompactTextString(m) }
func (*SetDataRequest) ProtoMessage()    {}
func (*SetDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{28}
}
func (m *SetDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetDataRequest.Merge(m, src)
}
func (m *SetDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetDataRequest proto.InternalMessageInfo

func (m *SetDataRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *SetDataRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *SetDataRequest) GetKeyAddr() string {
	if m != nil {
		return m.KeyAddr
	}
	return ""
}

func (m *SetDataRequest) GetPayload() *transactions.SetDataPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type SetDataResponse struct {
	Tip string `protobuf:"bytes,1,opt,name=tip,proto3" json:"tip,omitempty"`
}

func (m *SetDataResponse) Reset()         { *m = SetDataResponse{} }
func (m *SetDataResponse) String() string { return proto.CompactTextString(m) }
func (*SetDataResponse) ProtoMessage()    {}
func (*SetDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{29}
}
func (m *SetDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetDataResponse.Merge(m, src)
}
func (m *SetDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetDataResponse proto.InternalMessageInfo

func (m *SetDataResponse) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

type ResolveRequest struct {
	Creds   *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId string       `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Path    string       `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *ResolveRequest) Reset()         { *m = ResolveRequest{} }
func (m *ResolveRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveRequest) ProtoMessage()    {}
func (*ResolveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{30}
}
func (m *ResolveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveRequest.Merge(m, src)
}
func (m *ResolveRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResolveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveRequest proto.InternalMessageInfo

func (m *ResolveRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *ResolveRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ResolveRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type ResolveResponse struct {
	RemainingPath string `protobuf:"bytes,1,opt,name=remaining_path,json=remainingPath,proto3" json:"remaining_path,omitempty"`
	Data          []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ResolveResponse) Reset()         { *m = ResolveResponse{} }
func (m *ResolveResponse) String() string { return proto.CompactTextString(m) }
func (*ResolveResponse) ProtoMessage()    {}
func (*ResolveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{31}
}
func (m *ResolveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveResponse.Merge(m, src)
}
func (m *ResolveResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResolveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveResponse proto.InternalMessageInfo

func (m *ResolveResponse) GetRemainingPath() string {
	if m != nil {
		return m.RemainingPath
	}
	return ""
}

func (m *ResolveResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ResolveAtRequest struct {
	Creds   *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId string       `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Tip     string       `protobuf:"bytes,3,opt,name=tip,proto3" json:"tip,omitempty"`
	Path    string       `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *ResolveAtRequest) Reset()         { *m = ResolveAtRequest{} }
func (m *ResolveAtRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveAtRequest) ProtoMessage()    {}
func (*ResolveAtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{32}
}
func (m *ResolveAtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveAtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolveAtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolveAtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveAtRequest.Merge(m, src)
}
func (m *ResolveAtRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResolveAtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveAtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveAtRequest proto.InternalMessageInfo

func (m *ResolveAtRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *ResolveAtRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ResolveAtRequest) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

func (m *ResolveAtRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type EstablishTokenRequest struct {
	Creds   *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId string       `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	KeyAddr string       `protobuf:"bytes,3,opt,name=key_addr,json=keyAddr,proto3" json:"key_addr,omitempty"`
	// indexes 4 and 5 are deleted keys and intentionally omitted
	Payload *transactions.EstablishTokenPayload `protobuf:"bytes,6,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *EstablishTokenRequest) Reset()         { *m = EstablishTokenRequest{} }
func (m *EstablishTokenRequest) String() string { return proto.CompactTextString(m) }
func (*EstablishTokenRequest) ProtoMessage()    {}
func (*EstablishTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{33}
}
func (m *EstablishTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstablishTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstablishTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstablishTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstablishTokenRequest.Merge(m, src)
}
func (m *EstablishTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *EstablishTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EstablishTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EstablishTokenRequest proto.InternalMessageInfo

func (m *EstablishTokenRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *EstablishTokenRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *EstablishTokenRequest) GetKeyAddr() string {
	if m != nil {
		return m.KeyAddr
	}
	return ""
}

func (m *EstablishTokenRequest) GetPayload() *transactions.EstablishTokenPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type EstablishTokenResponse struct {
	Tip string `protobuf:"bytes,1,opt,name=tip,proto3" json:"tip,omitempty"`
}

func (m *EstablishTokenResponse) Reset()         { *m = EstablishTokenResponse{} }
func (m *EstablishTokenResponse) String() string { return proto.CompactTextString(m) }
func (*EstablishTokenResponse) ProtoMessage()    {}
func (*EstablishTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{34}
}
func (m *EstablishTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstablishTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstablishTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstablishTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstablishTokenResponse.Merge(m, src)
}
func (m *EstablishTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *EstablishTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EstablishTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EstablishTokenResponse proto.InternalMessageInfo

func (m *EstablishTokenResponse) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

type MintTokenRequest struct {
	Creds   *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId string       `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	KeyAddr string       `protobuf:"bytes,3,opt,name=key_addr,json=keyAddr,proto3" json:"key_addr,omitempty"`
	// indexes 4 and 5 are deleted keys and intentionally omitted
	Payload *transactions.MintTokenPayload `protobuf:"bytes,6,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *MintTokenRequest) Reset()         { *m = MintTokenRequest{} }
func (m *MintTokenRequest) String() string { return proto.CompactTextString(m) }
func (*MintTokenRequest) ProtoMessage()    {}
func (*MintTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{35}
}
func (m *MintTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MintTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MintTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MintTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MintTokenRequest.Merge(m, src)
}
func (m *MintTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *MintTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MintTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MintTokenRequest proto.InternalMessageInfo

func (m *MintTokenRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *MintTokenRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *MintTokenRequest) GetKeyAddr() string {
	if m != nil {
		return m.KeyAddr
	}
	return ""
}

func (m *MintTokenRequest) GetPayload() *transactions.MintTokenPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type MintTokenResponse struct {
	Tip string `protobuf:"bytes,1,opt,name=tip,proto3" json:"tip,omitempty"`
}

func (m *MintTokenResponse) Reset()         { *m = MintTokenResponse{} }
func (m *MintTokenResponse) String() string { return proto.CompactTextString(m) }
func (*MintTokenResponse) ProtoMessage()    {}
func (*MintTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{36}
}
func (m *MintTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MintTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MintTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MintTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MintTokenResponse.Merge(m, src)
}
func (m *MintTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *MintTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MintTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MintTokenResponse proto.InternalMessageInfo

func (m *MintTokenResponse) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

type SendTokenRequest struct {
	Creds              *Credentials                   `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId            string                         `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	KeyAddr            string                         `protobuf:"bytes,3,opt,name=key_addr,json=keyAddr,proto3" json:"key_addr,omitempty"`
	TokenName          string                         `protobuf:"bytes,4,opt,name=token_name,json=tokenName,proto3" json:"token_name,omitempty"`
	DestinationChainId string                         `protobuf:"bytes,5,opt,name=destination_chain_id,json=destinationChainId,proto3" json:"destination_chain_id,omitempty"`
	Amount             uint64                         `protobuf:"varint,6,opt,name=amount,proto3" json:"amount,omitempty"`
	Payload            *transactions.SendTokenPayload `protobuf:"bytes,7,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *SendTokenRequest) Reset()         { *m = SendTokenRequest{} }
func (m *SendTokenRequest) String() string { return proto.CompactTextString(m) }
func (*SendTokenRequest) ProtoMessage()    {}
func (*SendTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{37}
}
func (m *SendTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendTokenRequest.Merge(m, src)
}
func (m *SendTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendTokenRequest proto.InternalMessageInfo

func (m *SendTokenRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *SendTokenRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *SendTokenRequest) GetKeyAddr() string {
	if m != nil {
		return m.KeyAddr
	}
	return ""
}

func (m *SendTokenRequest) GetTokenName() string {
	if m != nil {
		return m.TokenName
	}
	return ""
}

func (m *SendTokenRequest) GetDestinationChainId() string {
	if m != nil {
		return m.DestinationChainId
	}
	return ""
}

func (m *SendTokenRequest) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *SendTokenRequest) GetPayload() *transactions.SendTokenPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type SendTokenResponse struct {
	SendToken string `protobuf:"bytes,1,opt,name=send_token,json=sendToken,proto3" json:"send_token,omitempty"`
	Tip       string `protobuf:"bytes,2,opt,name=tip,proto3" json:"tip,omitempty"`
}

func (m *SendTokenResponse) Reset()         { *m = SendTokenResponse{} }
func (m *SendTokenResponse) String() string { return proto.CompactTextString(m) }
func (*SendTokenResponse) ProtoMessage()    {}
func (*SendTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{38}
}
func (m *SendTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendTokenResponse.Merge(m, src)
}
func (m *SendTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *SendTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendTokenResponse proto.InternalMessageInfo

func (m *SendTokenResponse) GetSendToken() string {
	if m != nil {
		return m.SendToken
	}
	return ""
}

func (m *SendTokenResponse) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

type ReceiveTokenRequest struct {
	Creds        *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId      string       `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	KeyAddr      string       `protobuf:"bytes,3,opt,name=key_addr,json=keyAddr,proto3" json:"key_addr,omitempty"`
	TokenPayload string       `protobuf:"bytes,4,opt,name=token_payload,json=tokenPayload,proto3" json:"token_payload,omitempty"`
}

func (m *ReceiveTokenRequest) Reset()         { *m = ReceiveTokenRequest{} }
func (m *ReceiveTokenRequest) String() string { return proto.CompactTextString(m) }
func (*ReceiveTokenRequest) ProtoMessage()    {}
func (*ReceiveTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{39}
}
func (m *ReceiveTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveTokenRequest.Merge(m, src)
}
func (m *ReceiveTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveTokenRequest proto.InternalMessageInfo

func (m *ReceiveTokenRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *ReceiveTokenRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ReceiveTokenRequest) GetKeyAddr() string {
	if m != nil {
		return m.KeyAddr
	}
	return ""
}

func (m *ReceiveTokenRequest) GetTokenPayload() string {
	if m != nil {
		return m.TokenPayload
	}
	return ""
}

type ReceiveTokenResponse struct {
	Tip string `protobuf:"bytes,1,opt,name=tip,proto3" json:"tip,omitempty"`
}

func (m *ReceiveTokenResponse) Reset()         { *m = ReceiveTokenResponse{} }
func (m *ReceiveTokenResponse) String() string { return proto.CompactTextString(m) }
func (*ReceiveTokenResponse) ProtoMessage()    {}
func (*ReceiveTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{40}
}
func (m *ReceiveTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveTokenResponse.Merge(m, src)
}
func (m *ReceiveTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveTokenResponse proto.InternalMessageInfo

func (m *ReceiveTokenResponse) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

type GetTokenBalanceRequest struct {
	Creds     *Credentials `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId   string       `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TokenName string       `protobuf:"bytes,3,opt,name=token_name,json=tokenName,proto3" json:"token_name,omitempty"`
}

func (m *GetTokenBalanceRequest) Reset()         { *m = GetTokenBalanceRequest{} }
func (m *GetTokenBalanceRequest) String() string { return proto.CompactTextString(m) }
func (*GetTokenBalanceRequest) ProtoMessage()    {}
func (*GetTokenBalanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{41}
}
func (m *GetTokenBalanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTokenBalanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTokenBalanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTokenBalanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenBalanceRequest.Merge(m, src)
}
func (m *GetTokenBalanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTokenBalanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenBalanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenBalanceRequest proto.InternalMessageInfo

func (m *GetTokenBalanceRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *GetTokenBalanceRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *GetTokenBalanceRequest) GetTokenName() string {
	if m != nil {
		return m.TokenName
	}
	return ""
}

type GetTokenBalanceResponse struct {
	Amount uint64 `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *GetTokenBalanceResponse) Reset()         { *m = GetTokenBalanceResponse{} }
func (m *GetTokenBalanceResponse) String() string { return proto.CompactTextString(m) }
func (*GetTokenBalanceResponse) ProtoMessage()    {}
func (*GetTokenBalanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{42}
}
func (m *GetTokenBalanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTokenBalanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTokenBalanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTokenBalanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenBalanceResponse.Merge(m, src)
}
func (m *GetTokenBalanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTokenBalanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenBalanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenBalanceResponse proto.InternalMessageInfo

func (m *GetTokenBalanceResponse) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type PlayTransactionsRequest struct {
	Creds        *Credentials                `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
	ChainId      string                      `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	KeyAddr      string                      `protobuf:"bytes,3,opt,name=key_addr,json=keyAddr,proto3" json:"key_addr,omitempty"`
	Transactions []*transactions.Transaction `protobuf:"bytes,4,rep,name=transactions,proto3" json:"transactions,omitempty"`
}

func (m *PlayTransactionsRequest) Reset()         { *m = PlayTransactionsRequest{} }
func (m *PlayTransactionsRequest) String() string { return proto.CompactTextString(m) }
func (*PlayTransactionsRequest) ProtoMessage()    {}
func (*PlayTransactionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{43}
}
func (m *PlayTransactionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayTransactionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayTransactionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayTransactionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayTransactionsRequest.Merge(m, src)
}
func (m *PlayTransactionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *PlayTransactionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayTransactionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PlayTransactionsRequest proto.InternalMessageInfo

func (m *PlayTransactionsRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *PlayTransactionsRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *PlayTransactionsRequest) GetKeyAddr() string {
	if m != nil {
		return m.KeyAddr
	}
	return ""
}

func (m *PlayTransactionsRequest) GetTransactions() []*transactions.Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type PlayTransactionsResponse struct {
	Tip string `protobuf:"bytes,1,opt,name=tip,proto3" json:"tip,omitempty"`
}

func (m *PlayTransactionsResponse) Reset()         { *m = PlayTransactionsResponse{} }
func (m *PlayTransactionsResponse) String() string { return proto.CompactTextString(m) }
func (*PlayTransactionsResponse) ProtoMessage()    {}
func (*PlayTransactionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_20616c573d3cd2a9, []int{44}
}
func (m *PlayTransactionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayTransactionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayTransactionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayTransactionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayTransactionsResponse.Merge(m, src)
}
func (m *PlayTransactionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *PlayTransactionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayTransactionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PlayTransactionsResponse proto.InternalMessageInfo

func (m *PlayTransactionsResponse) GetTip() string {
	if m != nil {
		return m.Tip
	}
	return ""
}

func init() {
	proto.RegisterType((*AddBlockRequest)(nil), "v1services.AddBlockRequest")
	proto.RegisterType((*ReceiveCurrentStateSnapshot)(nil), "v1services.ReceiveCurrentStateSnapshot")
	proto.RegisterType((*RequestCurrentStateSnapshot)(nil), "v1services.RequestCurrentStateSnapshot")
	proto.RegisterType((*Ping)(nil), "v1services.Ping")
	proto.RegisterType((*Pong)(nil), "v1services.Pong")
	proto.RegisterType((*Credentials)(nil), "v1services.Credentials")
	proto.RegisterType((*SerializableChainTree)(nil), "v1services.SerializableChainTree")
	proto.RegisterMapType((map[string]*signatures.Signature)(nil), "v1services.SerializableChainTree.SignaturesEntry")
	proto.RegisterType((*RegisterWalletRequest)(nil), "v1services.RegisterWalletRequest")
	proto.RegisterType((*RegisterWalletResponse)(nil), "v1services.RegisterWalletResponse")
	proto.RegisterType((*StorageAdapterConfigForBadger)(nil), "v1services.StorageAdapterConfigForBadger")
	proto.RegisterType((*StorageAdapterConfigForIpld)(nil), "v1services.StorageAdapterConfigForIpld")
	proto.RegisterType((*StorageAdapterConfig)(nil), "v1services.StorageAdapterConfig")
	proto.RegisterType((*GenerateChainRequest)(nil), "v1services.GenerateChainRequest")
	proto.RegisterType((*GenerateChainResponse)(nil), "v1services.GenerateChainResponse")
	proto.RegisterType((*ExportChainRequest)(nil), "v1services.ExportChainRequest")
	proto.RegisterType((*ExportChainResponse)(nil), "v1services.ExportChainResponse")
	proto.RegisterType((*ImportChainRequest)(nil), "v1services.ImportChainRequest")
	proto.RegisterType((*ImportChainResponse)(nil), "v1services.ImportChainResponse")
	proto.RegisterType((*GenerateKeyRequest)(nil), "v1services.GenerateKeyRequest")
	proto.RegisterType((*GenerateKeyResponse)(nil), "v1services.GenerateKeyResponse")
	proto.RegisterType((*GetTipRequest)(nil), "v1services.GetTipRequest")
	proto.RegisterType((*GetTipResponse)(nil), "v1services.GetTipResponse")
	proto.RegisterType((*ListChainIdsRequest)(nil), "v1services.ListChainIdsRequest")
	proto.RegisterType((*ListChainIdsResponse)(nil), "v1services.ListChainIdsResponse")
	proto.RegisterType((*ListKeysRequest)(nil), "v1services.ListKeysRequest")
	proto.RegisterType((*ListKeysResponse)(nil), "v1services.ListKeysResponse")
	proto.RegisterType((*SetOwnerRequest)(nil), "v1services.SetOwnerRequest")
	proto.RegisterType((*SetOwnerResponse)(nil), "v1services.SetOwnerResponse")
	proto.RegisterType((*SetDataRequest)(nil), "v1services.SetDataRequest")
	proto.RegisterType((*SetDataResponse)(nil), "v1services.SetDataResponse")
	proto.RegisterType((*ResolveRequest)(nil), "v1services.ResolveRequest")
	proto.RegisterType((*ResolveResponse)(nil), "v1services.ResolveResponse")
	proto.RegisterType((*ResolveAtRequest)(nil), "v1services.ResolveAtRequest")
	proto.RegisterType((*EstablishTokenRequest)(nil), "v1services.EstablishTokenRequest")
	proto.RegisterType((*EstablishTokenResponse)(nil), "v1services.EstablishTokenResponse")
	proto.RegisterType((*MintTokenRequest)(nil), "v1services.MintTokenRequest")
	proto.RegisterType((*MintTokenResponse)(nil), "v1services.MintTokenResponse")
	proto.RegisterType((*SendTokenRequest)(nil), "v1services.SendTokenRequest")
	proto.RegisterType((*SendTokenResponse)(nil), "v1services.SendTokenResponse")
	proto.RegisterType((*ReceiveTokenRequest)(nil), "v1services.ReceiveTokenRequest")
	proto.RegisterType((*ReceiveTokenResponse)(nil), "v1services.ReceiveTokenResponse")
	proto.RegisterType((*GetTokenBalanceRequest)(nil), "v1services.GetTokenBalanceRequest")
	proto.RegisterType((*GetTokenBalanceResponse)(nil), "v1services.GetTokenBalanceResponse")
	proto.RegisterType((*PlayTransactionsRequest)(nil), "v1services.PlayTransactionsRequest")
	proto.RegisterType((*PlayTransactionsResponse)(nil), "v1services.PlayTransactionsResponse")
}

func init() { proto.RegisterFile("services/services.proto", fileDescriptor_20616c573d3cd2a9) }

var fileDescriptor_20616c573d3cd2a9 = []byte{
	// 1657 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xdd, 0x6e, 0xdb, 0xc8,
	0x15, 0x36, 0x2d, 0xd9, 0x96, 0x8e, 0x1c, 0x49, 0x19, 0xff, 0x29, 0x52, 0xac, 0x28, 0x74, 0x82,
	0xb8, 0x45, 0x63, 0xc7, 0x76, 0x81, 0xa6, 0x01, 0x82, 0xd4, 0x56, 0x9c, 0xc4, 0xc8, 0x9f, 0x4d,
	0x19, 0x09, 0x5a, 0xa0, 0x15, 0xc6, 0xe2, 0x44, 0x62, 0x4d, 0x91, 0x0c, 0x67, 0x24, 0x57, 0xbd,
	0x6b, 0x9f, 0xa0, 0x0f, 0x50, 0xa0, 0x0f, 0xd0, 0x05, 0x16, 0xd8, 0xc5, 0x5e, 0x2e, 0xf6, 0x6e,
	0xb1, 0x97, 0xb9, 0x5a, 0xec, 0xe5, 0x22, 0x01, 0xf6, 0x39, 0x16, 0x1c, 0x0e, 0x29, 0x0e, 0x45,
	0x39, 0x0b, 0xc7, 0xeb, 0x3b, 0xce, 0xcc, 0x39, 0xdf, 0xf9, 0xd5, 0xcc, 0x77, 0x04, 0x4b, 0x94,
	0xb8, 0x7d, 0xa3, 0x45, 0xe8, 0x7a, 0xf0, 0xb1, 0xe6, 0xb8, 0x36, 0xb3, 0x11, 0xf4, 0x37, 0x82,
	0x9d, 0x72, 0x85, 0x1a, 0x6d, 0x0b, 0xb3, 0x9e, 0xeb, 0x89, 0x85, 0x9f, 0xbe, 0x60, 0xf9, 0x1a,
	0x73, 0xb1, 0x45, 0x71, 0x8b, 0x19, 0xb6, 0x45, 0xd7, 0xa3, 0x0b, 0x5f, 0x40, 0xfd, 0x42, 0x81,
	0xc2, 0xb6, 0xae, 0xef, 0x98, 0x76, 0xeb, 0x58, 0x23, 0x6f, 0x7b, 0x84, 0x32, 0x54, 0x81, 0xac,
	0x7d, 0xf4, 0x77, 0xd2, 0x62, 0x4d, 0x43, 0x2f, 0x29, 0x35, 0x65, 0x75, 0x56, 0xcb, 0xf8, 0x1b,
	0x7b, 0x3a, 0xba, 0x0e, 0xb3, 0x8e, 0x4b, 0xfa, 0x86, 0xdd, 0xa3, 0x4d, 0x66, 0x38, 0xa5, 0x49,
	0x7e, 0x9e, 0x0b, 0xf6, 0x0e, 0x0d, 0x07, 0x2d, 0xc2, 0x74, 0x87, 0x18, 0xed, 0x0e, 0x2b, 0xa5,
	0x6a, 0xca, 0x6a, 0x5a, 0x13, 0x2b, 0xb4, 0x04, 0x33, 0x16, 0x39, 0xe1, 0x5a, 0x69, 0xae, 0x35,
	0x6d, 0x91, 0x13, 0x4f, 0xa1, 0x04, 0x33, 0x0e, 0x1e, 0x98, 0x36, 0xd6, 0x4b, 0x53, 0xfc, 0x20,
	0x58, 0xa2, 0x79, 0x98, 0xa2, 0x0c, 0x33, 0x52, 0x9a, 0xae, 0xa5, 0x56, 0x67, 0x35, 0x7f, 0xa1,
	0xfe, 0x01, 0x2a, 0x1a, 0x69, 0x11, 0xa3, 0x4f, 0xea, 0x3d, 0xd7, 0x25, 0x16, 0x6b, 0x78, 0xdb,
	0x0d, 0x0b, 0x3b, 0xb4, 0x63, 0xb3, 0x28, 0x9c, 0x22, 0xc1, 0xa9, 0xcb, 0x9e, 0x22, 0x0f, 0x32,
	0x49, 0x51, 0x2d, 0x41, 0x7a, 0xdf, 0xb0, 0xda, 0xa8, 0x08, 0xa9, 0x2e, 0x6d, 0x73, 0xe5, 0xac,
	0xe6, 0x7d, 0xf2, 0x13, 0x3b, 0xf1, 0xe4, 0x25, 0xe4, 0xea, 0x2e, 0xd1, 0x89, 0xc5, 0x0c, 0x6c,
	0x52, 0x74, 0x0d, 0x72, 0x27, 0xd8, 0x34, 0x09, 0x6b, 0x5a, 0xb8, 0x4b, 0x84, 0x20, 0xf8, 0x5b,
	0x2f, 0x70, 0x97, 0x78, 0x02, 0x0e, 0xa6, 0xb4, 0xe9, 0x74, 0x5c, 0x4c, 0x09, 0x4f, 0x5f, 0x56,
	0x03, 0x6f, 0x6b, 0x9f, 0xef, 0xa8, 0x3f, 0x29, 0xb0, 0xd0, 0x20, 0xae, 0x81, 0x4d, 0xe3, 0x9f,
	0xf8, 0xc8, 0x24, 0xf5, 0x0e, 0x36, 0xac, 0x43, 0x97, 0x10, 0xcf, 0xb8, 0x8e, 0x3d, 0xe3, 0x5e,
	0x2a, 0xbc, 0x4f, 0x74, 0x00, 0x30, 0x2c, 0x79, 0x69, 0xb2, 0x96, 0x5a, 0xcd, 0x6d, 0x6e, 0xac,
	0x0d, 0x9b, 0x63, 0x2d, 0x11, 0x68, 0xad, 0x11, 0xea, 0xec, 0x5a, 0xcc, 0x1d, 0x68, 0x11, 0x10,
	0xcf, 0x88, 0x57, 0xa0, 0x94, 0x1f, 0x21, 0x33, 0x9c, 0xf2, 0x2b, 0x28, 0xc4, 0x14, 0x3c, 0xa1,
	0x63, 0x32, 0x08, 0xd2, 0x70, 0x4c, 0x06, 0xe8, 0x36, 0x4c, 0xf5, 0xb1, 0xd9, 0xf3, 0x03, 0xca,
	0x6d, 0x2e, 0x79, 0x4e, 0x0c, 0x9b, 0x31, 0xd4, 0xd7, 0x7c, 0xa9, 0x7b, 0x93, 0x77, 0x15, 0xf5,
	0x11, 0x2c, 0x68, 0xa4, 0x6d, 0x50, 0x46, 0xdc, 0xd7, 0x3c, 0x3f, 0x41, 0xff, 0xdd, 0x86, 0xa9,
	0x96, 0x4b, 0x74, 0xca, 0xf1, 0x05, 0x56, 0x10, 0x50, 0x24, 0xd7, 0x9a, 0x2f, 0xa5, 0xfe, 0x11,
	0x16, 0xe3, 0x38, 0xd4, 0xb1, 0x2d, 0x4a, 0x3e, 0x5a, 0x0c, 0x75, 0x0b, 0x96, 0x1b, 0xcc, 0x76,
	0x71, 0x9b, 0x6c, 0xeb, 0xd8, 0x61, 0xc4, 0xad, 0xdb, 0xd6, 0x1b, 0xa3, 0xfd, 0xc8, 0x76, 0x77,
	0xb0, 0xde, 0x26, 0x2e, 0x42, 0x90, 0x76, 0x30, 0xeb, 0x08, 0x55, 0xfe, 0xad, 0x12, 0xa8, 0x8c,
	0x51, 0xda, 0x73, 0x4c, 0x3d, 0x49, 0xc5, 0xeb, 0x48, 0xac, 0xeb, 0x2e, 0xa1, 0x54, 0x14, 0x3c,
	0x58, 0x7a, 0x27, 0xf6, 0x9b, 0x37, 0xa6, 0x61, 0x11, 0x9e, 0xf2, 0x8c, 0x16, 0x2c, 0xd5, 0xcf,
	0x14, 0x98, 0x4f, 0xb2, 0x83, 0xea, 0x30, 0x7d, 0xc4, 0xbd, 0x13, 0xf9, 0xf9, 0x8d, 0x54, 0xf0,
	0xd3, 0xc2, 0x79, 0x32, 0xa1, 0x09, 0x55, 0x74, 0x1f, 0xd2, 0x86, 0x63, 0xea, 0xa2, 0x5c, 0xb7,
	0x7e, 0x01, 0x84, 0x17, 0xdc, 0x93, 0x09, 0x8d, 0xab, 0xed, 0x14, 0x21, 0x8f, 0xfd, 0xf3, 0x66,
	0x8b, 0x0b, 0xa8, 0xff, 0x57, 0x60, 0xfe, 0x31, 0xb1, 0x88, 0x8b, 0x99, 0xdf, 0x69, 0x67, 0xab,
	0x26, 0xba, 0x02, 0x99, 0x63, 0x32, 0x68, 0x7a, 0xf9, 0x09, 0x72, 0x75, 0x4c, 0x06, 0xdb, 0xba,
	0xee, 0xa2, 0x3d, 0x28, 0x50, 0xdf, 0xb7, 0xa6, 0x30, 0xce, 0x73, 0x96, 0xdb, 0xac, 0x7d, 0xcc,
	0x7d, 0x2d, 0x4f, 0xa5, 0x5d, 0x75, 0x13, 0x16, 0x62, 0xce, 0x8a, 0x96, 0xb9, 0x02, 0x99, 0x96,
	0xb7, 0x11, 0x5c, 0x7d, 0x59, 0x6d, 0x86, 0xaf, 0xf7, 0x74, 0xf5, 0x6f, 0x80, 0x76, 0xff, 0xe1,
	0xd8, 0x2e, 0xfb, 0xc4, 0xf0, 0x42, 0xfc, 0x49, 0x19, 0xff, 0xf7, 0x30, 0x27, 0xe1, 0x0b, 0x8f,
	0x96, 0x01, 0x7c, 0x0d, 0xe6, 0x92, 0xa0, 0x87, 0xb3, 0xad, 0xe0, 0xb7, 0xac, 0x7e, 0xaf, 0x00,
	0xda, 0xeb, 0x7e, 0xaa, 0x5b, 0xb2, 0x91, 0x54, 0xcc, 0x48, 0x52, 0xe6, 0xd3, 0x67, 0xcb, 0x3c,
	0xba, 0x05, 0x05, 0x7a, 0x6c, 0x38, 0xcd, 0x3e, 0x36, 0x0d, 0x1d, 0x7b, 0x4f, 0x11, 0xbf, 0xf3,
	0x33, 0x5a, 0xde, 0xdb, 0x7e, 0x15, 0xee, 0xaa, 0x77, 0x60, 0x4e, 0x8a, 0xeb, 0xe3, 0x05, 0xaa,
	0x03, 0x0a, 0x8a, 0xfa, 0x94, 0x0c, 0xce, 0x78, 0x9b, 0xdc, 0x81, 0x39, 0x09, 0x64, 0x68, 0x36,
	0x6c, 0x4b, 0x45, 0x6a, 0x4b, 0xf5, 0xcf, 0x70, 0xe9, 0x31, 0x61, 0x87, 0x86, 0x73, 0xfe, 0x2d,
	0xa1, 0x42, 0x3e, 0x80, 0x16, 0x7e, 0x88, 0xeb, 0x59, 0x09, 0xaf, 0x67, 0xf5, 0x21, 0xcc, 0x3d,
	0x33, 0xa8, 0x9f, 0xa5, 0x3d, 0x9d, 0x9e, 0x31, 0xec, 0x2d, 0x98, 0x97, 0x51, 0x84, 0xbd, 0x0a,
	0x64, 0x03, 0xe7, 0x28, 0x7f, 0x79, 0xb2, 0x5a, 0x46, 0x78, 0x47, 0xd5, 0x3f, 0x41, 0xc1, 0x53,
	0x7a, 0x4a, 0x06, 0x67, 0x35, 0xbb, 0x0e, 0xc5, 0x21, 0xc2, 0xd0, 0x64, 0x90, 0xea, 0xd0, 0xa4,
	0xc8, 0x35, 0x55, 0xbf, 0x52, 0xa0, 0xd0, 0x20, 0xec, 0xe5, 0x89, 0x45, 0xdc, 0x73, 0xcf, 0xb7,
	0x54, 0xe5, 0x94, 0x7c, 0xf9, 0xdc, 0x97, 0x39, 0x4a, 0x6e, 0x73, 0x65, 0xad, 0xbf, 0x21, 0x11,
	0xaa, 0xc0, 0x2d, 0xda, 0x31, 0x9c, 0x7d, 0x5f, 0x74, 0xc8, 0x3c, 0x6e, 0x40, 0x71, 0xe8, 0xf6,
	0xd8, 0x5a, 0x7e, 0xae, 0x40, 0xbe, 0x41, 0xd8, 0x43, 0xcc, 0xf0, 0x85, 0x06, 0x77, 0x77, 0x18,
	0xdc, 0x34, 0x37, 0x53, 0x4d, 0x08, 0xce, 0xf3, 0x6a, 0x24, 0xae, 0x15, 0x5e, 0x0e, 0xdf, 0xe1,
	0xb1, 0x61, 0x59, 0x90, 0xd7, 0x08, 0xb5, 0xcd, 0x3e, 0x39, 0xff, 0xa8, 0x82, 0xe7, 0x36, 0x15,
	0x79, 0xa1, 0x9f, 0x41, 0x21, 0xb4, 0x27, 0x9c, 0xba, 0x09, 0x79, 0x97, 0x74, 0xb1, 0x61, 0x19,
	0x56, 0xbb, 0x19, 0x79, 0x9f, 0x2f, 0x85, 0xbb, 0xfb, 0xde, 0x43, 0x8d, 0x20, 0xad, 0x63, 0x86,
	0x05, 0xab, 0xe5, 0xdf, 0xea, 0xbf, 0x15, 0x28, 0x0a, 0xb8, 0x6d, 0x76, 0xfe, 0x01, 0x8c, 0x10,
	0xae, 0x30, 0xa4, 0x74, 0x24, 0xa4, 0xaf, 0x15, 0x58, 0xd8, 0xa5, 0x0c, 0x1f, 0x99, 0x06, 0xed,
	0x1c, 0xda, 0xc7, 0xc4, 0xba, 0xd0, 0x06, 0x79, 0x10, 0x6f, 0x90, 0x9b, 0xf1, 0x06, 0x91, 0x9d,
	0x1b, 0xe9, 0x93, 0xdf, 0xc2, 0x62, 0xdc, 0xfd, 0xb1, 0xed, 0xf2, 0xa5, 0x02, 0xc5, 0xe7, 0x86,
	0xc5, 0x2e, 0x3e, 0xcc, 0x7b, 0xf1, 0x30, 0x6b, 0xf1, 0x30, 0x43, 0xbf, 0x46, 0x22, 0xbc, 0x09,
	0x97, 0x23, 0x4e, 0x8f, 0x0d, 0xee, 0xbf, 0x93, 0xde, 0x4d, 0x60, 0xe9, 0x17, 0x1f, 0xdc, 0x32,
	0x00, 0xf3, 0x8c, 0xfa, 0x64, 0xd8, 0x6f, 0xae, 0x2c, 0xdf, 0xe1, 0x83, 0xc9, 0x1d, 0x98, 0xd7,
	0x09, 0x65, 0x86, 0xc5, 0x9f, 0xdf, 0x66, 0x68, 0x60, 0x8a, 0x0b, 0xa2, 0xc8, 0x99, 0x78, 0x24,
	0xbc, 0x39, 0x0f, 0x77, 0xed, 0x9e, 0xc5, 0x78, 0xb2, 0xd2, 0x9a, 0x58, 0x45, 0xb3, 0x38, 0x93,
	0x9c, 0xc5, 0x30, 0x01, 0x23, 0x59, 0x7c, 0x08, 0x97, 0x23, 0xd9, 0x19, 0x52, 0x20, 0x4a, 0x2c,
	0xbd, 0xc9, 0x9d, 0x0d, 0x28, 0x10, 0x0d, 0xc4, 0x82, 0x24, 0x4f, 0x0e, 0x93, 0xfc, 0x3f, 0x05,
	0xe6, 0xc4, 0x84, 0x78, 0xf1, 0x79, 0x5e, 0x81, 0x4b, 0x7e, 0x9e, 0x83, 0x24, 0xf8, 0xa9, 0x9e,
	0x65, 0x91, 0x80, 0xd5, 0x55, 0x98, 0x97, 0x1d, 0x1c, 0xdb, 0x30, 0xff, 0x52, 0x60, 0xd1, 0x23,
	0x01, 0x9e, 0xd8, 0x0e, 0x36, 0xb1, 0xd5, 0xfa, 0x15, 0x6e, 0x51, 0xb9, 0x37, 0x52, 0xb1, 0xde,
	0x50, 0x37, 0x60, 0x69, 0xc4, 0x05, 0xe1, 0xf0, 0xb0, 0x09, 0x94, 0x68, 0x13, 0xa8, 0xdf, 0x28,
	0xb0, 0xb4, 0x6f, 0xe2, 0xc1, 0x61, 0xa4, 0xee, 0x17, 0x7c, 0x65, 0xcd, 0x46, 0x7b, 0xae, 0x94,
	0xe6, 0xd3, 0x71, 0x25, 0xde, 0x8a, 0x11, 0xff, 0x34, 0x49, 0x41, 0xfd, 0x1d, 0x94, 0x46, 0x03,
	0x18, 0x57, 0xa6, 0xcd, 0x6f, 0x01, 0x8a, 0x62, 0xfc, 0xdc, 0xaf, 0x37, 0xfc, 0x68, 0xd0, 0x01,
	0x64, 0x82, 0xd1, 0x14, 0x5d, 0x8f, 0x46, 0x99, 0x38, 0xf8, 0x96, 0xd5, 0xd3, 0x44, 0x84, 0xe5,
	0x17, 0x90, 0x8b, 0xf0, 0x53, 0x54, 0x8d, 0xaa, 0x8c, 0xb2, 0xdf, 0xf2, 0xb5, 0xb1, 0xe7, 0x02,
	0xef, 0x15, 0x14, 0xea, 0x2e, 0x09, 0xe6, 0x20, 0xce, 0xf6, 0x6b, 0x49, 0x3a, 0xd1, 0xe9, 0xa2,
	0x7c, 0xfd, 0x14, 0x09, 0x81, 0xab, 0x41, 0x21, 0x32, 0xcd, 0x70, 0x5c, 0xc9, 0xd7, 0xd1, 0x51,
	0x4a, 0xf6, 0x35, 0x69, 0x14, 0xd2, 0xa0, 0x10, 0x19, 0x09, 0x46, 0x31, 0x47, 0xe7, 0x20, 0x19,
	0x33, 0x69, 0x9e, 0x78, 0x00, 0xd3, 0x3e, 0xc5, 0x46, 0x57, 0xe4, 0xa0, 0x22, 0x8c, 0xbe, 0x5c,
	0x4e, 0x3a, 0x12, 0x00, 0x07, 0x30, 0x1b, 0x65, 0xce, 0x48, 0xb2, 0x98, 0xc0, 0xcc, 0xcb, 0xb5,
	0xf1, 0x02, 0x02, 0x72, 0x17, 0x32, 0x01, 0x2b, 0x46, 0x95, 0xb8, 0x74, 0x84, 0x6d, 0x97, 0xaf,
	0x26, 0x1f, 0x0e, 0x61, 0x02, 0xce, 0x29, 0xc3, 0xc4, 0x08, 0xb4, 0x0c, 0x33, 0x42, 0x53, 0x77,
	0x60, 0x46, 0x50, 0x3c, 0x54, 0x8e, 0x09, 0x46, 0x88, 0x6a, 0xb9, 0x92, 0x78, 0x36, 0xc4, 0x10,
	0x14, 0x4a, 0xc6, 0x90, 0x69, 0xa1, 0x8c, 0x11, 0xa7, 0x70, 0x8f, 0x20, 0x1b, 0xd2, 0x30, 0x74,
	0x35, 0x41, 0x32, 0x64, 0x67, 0xa7, 0xe3, 0xbc, 0x86, 0xbc, 0x4c, 0x45, 0xe4, 0x9f, 0x66, 0x22,
	0xcb, 0x92, 0x7f, 0x9a, 0x63, 0x98, 0xcc, 0x13, 0xc8, 0x86, 0x0c, 0x40, 0x76, 0x30, 0xce, 0x66,
	0xca, 0xcb, 0x63, 0x4e, 0x87, 0x48, 0xe1, 0x2b, 0x88, 0x62, 0xd5, 0x91, 0xa9, 0x83, 0x8c, 0x34,
	0xfa, 0x74, 0x1e, 0xc0, 0x6c, 0xf4, 0x9d, 0x91, 0xbb, 0x33, 0xe1, 0x89, 0x94, 0xbb, 0x33, 0xf1,
	0x89, 0xfa, 0x2b, 0x14, 0xe3, 0xf7, 0x22, 0x5a, 0x89, 0x6a, 0x8d, 0xb9, 0xf6, 0xcb, 0x37, 0x4e,
	0x17, 0xf2, 0xe1, 0x77, 0x9e, 0x7f, 0xf7, 0xbe, 0xaa, 0xbc, 0x7b, 0x5f, 0x55, 0x7e, 0x7c, 0x5f,
	0x55, 0xfe, 0xf3, 0xa1, 0x3a, 0xf1, 0xee, 0x43, 0x75, 0xe2, 0x87, 0x0f, 0xd5, 0x89, 0xbf, 0x6c,
	0xb5, 0x0d, 0xd6, 0xe9, 0x1d, 0xad, 0xb5, 0xec, 0xee, 0xfa, 0xdb, 0x9e, 0xed, 0xf6, 0xba, 0x2d,
	0xdb, 0x62, 0xae, 0x6d, 0xae, 0x77, 0x09, 0xa5, 0xb8, 0x4d, 0xe8, 0xfa, 0x51, 0xcf, 0x30, 0xf5,
	0xf5, 0xb6, 0x1d, 0xfe, 0x61, 0x7e, 0x34, 0xcd, 0xff, 0xe7, 0xde, 0xfa, 0x39, 0x00, 0x00, 0xff,
	0xff, 0x6f, 0x81, 0xcd, 0x50, 0x4c, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WalletRPCServiceClient is the client API for WalletRPCService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WalletRPCServiceClient interface {
	Register(ctx context.Context, in *RegisterWalletRequest, opts ...grpc.CallOption) (*RegisterWalletResponse, error)
	GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error)
	CreateChainTree(ctx context.Context, in *GenerateChainRequest, opts ...grpc.CallOption) (*GenerateChainResponse, error)
	ExportChainTree(ctx context.Context, in *ExportChainRequest, opts ...grpc.CallOption) (*ExportChainResponse, error)
	ImportChainTree(ctx context.Context, in *ImportChainRequest, opts ...grpc.CallOption) (*ImportChainResponse, error)
	GetTip(ctx context.Context, in *GetTipRequest, opts ...grpc.CallOption) (*GetTipResponse, error)
	ListChainIds(ctx context.Context, in *ListChainIdsRequest, opts ...grpc.CallOption) (*ListChainIdsResponse, error)
	ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error)
	SetOwner(ctx context.Context, in *SetOwnerRequest, opts ...grpc.CallOption) (*SetOwnerResponse, error)
	SetData(ctx context.Context, in *SetDataRequest, opts ...grpc.CallOption) (*SetDataResponse, error)
	Resolve(ctx context.Context, in *ResolveRequest, opts ...grpc.CallOption) (*ResolveResponse, error)
	ResolveAt(ctx context.Context, in *ResolveAtRequest, opts ...grpc.CallOption) (*ResolveResponse, error)
	EstablishToken(ctx context.Context, in *EstablishTokenRequest, opts ...grpc.CallOption) (*EstablishTokenResponse, error)
	MintToken(ctx context.Context, in *MintTokenRequest, opts ...grpc.CallOption) (*MintTokenResponse, error)
	SendToken(ctx context.Context, in *SendTokenRequest, opts ...grpc.CallOption) (*SendTokenResponse, error)
	ReceiveToken(ctx context.Context, in *ReceiveTokenRequest, opts ...grpc.CallOption) (*ReceiveTokenResponse, error)
	PlayTransactions(ctx context.Context, in *PlayTransactionsRequest, opts ...grpc.CallOption) (*PlayTransactionsResponse, error)
}

type walletRPCServiceClient struct {
	cc *grpc.ClientConn
}

func NewWalletRPCServiceClient(cc *grpc.ClientConn) WalletRPCServiceClient {
	return &walletRPCServiceClient{cc}
}

func (c *walletRPCServiceClient) Register(ctx context.Context, in *RegisterWalletRequest, opts ...grpc.CallOption) (*RegisterWalletResponse, error) {
	out := new(RegisterWalletResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error) {
	out := new(GenerateKeyResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/GenerateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) CreateChainTree(ctx context.Context, in *GenerateChainRequest, opts ...grpc.CallOption) (*GenerateChainResponse, error) {
	out := new(GenerateChainResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/CreateChainTree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) ExportChainTree(ctx context.Context, in *ExportChainRequest, opts ...grpc.CallOption) (*ExportChainResponse, error) {
	out := new(ExportChainResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/ExportChainTree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) ImportChainTree(ctx context.Context, in *ImportChainRequest, opts ...grpc.CallOption) (*ImportChainResponse, error) {
	out := new(ImportChainResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/ImportChainTree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) GetTip(ctx context.Context, in *GetTipRequest, opts ...grpc.CallOption) (*GetTipResponse, error) {
	out := new(GetTipResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/GetTip", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) ListChainIds(ctx context.Context, in *ListChainIdsRequest, opts ...grpc.CallOption) (*ListChainIdsResponse, error) {
	out := new(ListChainIdsResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/ListChainIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error) {
	out := new(ListKeysResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/ListKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) SetOwner(ctx context.Context, in *SetOwnerRequest, opts ...grpc.CallOption) (*SetOwnerResponse, error) {
	out := new(SetOwnerResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/SetOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) SetData(ctx context.Context, in *SetDataRequest, opts ...grpc.CallOption) (*SetDataResponse, error) {
	out := new(SetDataResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/SetData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) Resolve(ctx context.Context, in *ResolveRequest, opts ...grpc.CallOption) (*ResolveResponse, error) {
	out := new(ResolveResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/Resolve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) ResolveAt(ctx context.Context, in *ResolveAtRequest, opts ...grpc.CallOption) (*ResolveResponse, error) {
	out := new(ResolveResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/ResolveAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) EstablishToken(ctx context.Context, in *EstablishTokenRequest, opts ...grpc.CallOption) (*EstablishTokenResponse, error) {
	out := new(EstablishTokenResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/EstablishToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) MintToken(ctx context.Context, in *MintTokenRequest, opts ...grpc.CallOption) (*MintTokenResponse, error) {
	out := new(MintTokenResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/MintToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) SendToken(ctx context.Context, in *SendTokenRequest, opts ...grpc.CallOption) (*SendTokenResponse, error) {
	out := new(SendTokenResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/SendToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) ReceiveToken(ctx context.Context, in *ReceiveTokenRequest, opts ...grpc.CallOption) (*ReceiveTokenResponse, error) {
	out := new(ReceiveTokenResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/ReceiveToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletRPCServiceClient) PlayTransactions(ctx context.Context, in *PlayTransactionsRequest, opts ...grpc.CallOption) (*PlayTransactionsResponse, error) {
	out := new(PlayTransactionsResponse)
	err := c.cc.Invoke(ctx, "/v1services.WalletRPCService/PlayTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WalletRPCServiceServer is the server API for WalletRPCService service.
type WalletRPCServiceServer interface {
	Register(context.Context, *RegisterWalletRequest) (*RegisterWalletResponse, error)
	GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error)
	CreateChainTree(context.Context, *GenerateChainRequest) (*GenerateChainResponse, error)
	ExportChainTree(context.Context, *ExportChainRequest) (*ExportChainResponse, error)
	ImportChainTree(context.Context, *ImportChainRequest) (*ImportChainResponse, error)
	GetTip(context.Context, *GetTipRequest) (*GetTipResponse, error)
	ListChainIds(context.Context, *ListChainIdsRequest) (*ListChainIdsResponse, error)
	ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error)
	SetOwner(context.Context, *SetOwnerRequest) (*SetOwnerResponse, error)
	SetData(context.Context, *SetDataRequest) (*SetDataResponse, error)
	Resolve(context.Context, *ResolveRequest) (*ResolveResponse, error)
	ResolveAt(context.Context, *ResolveAtRequest) (*ResolveResponse, error)
	EstablishToken(context.Context, *EstablishTokenRequest) (*EstablishTokenResponse, error)
	MintToken(context.Context, *MintTokenRequest) (*MintTokenResponse, error)
	SendToken(context.Context, *SendTokenRequest) (*SendTokenResponse, error)
	ReceiveToken(context.Context, *ReceiveTokenRequest) (*ReceiveTokenResponse, error)
	PlayTransactions(context.Context, *PlayTransactionsRequest) (*PlayTransactionsResponse, error)
}

// UnimplementedWalletRPCServiceServer can be embedded to have forward compatible implementations.
type UnimplementedWalletRPCServiceServer struct {
}

func (*UnimplementedWalletRPCServiceServer) Register(ctx context.Context, req *RegisterWalletRequest) (*RegisterWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (*UnimplementedWalletRPCServiceServer) GenerateKey(ctx context.Context, req *GenerateKeyRequest) (*GenerateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateKey not implemented")
}
func (*UnimplementedWalletRPCServiceServer) CreateChainTree(ctx context.Context, req *GenerateChainRequest) (*GenerateChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChainTree not implemented")
}
func (*UnimplementedWalletRPCServiceServer) ExportChainTree(ctx context.Context, req *ExportChainRequest) (*ExportChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportChainTree not implemented")
}
func (*UnimplementedWalletRPCServiceServer) ImportChainTree(ctx context.Context, req *ImportChainRequest) (*ImportChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportChainTree not implemented")
}
func (*UnimplementedWalletRPCServiceServer) GetTip(ctx context.Context, req *GetTipRequest) (*GetTipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTip not implemented")
}
func (*UnimplementedWalletRPCServiceServer) ListChainIds(ctx context.Context, req *ListChainIdsRequest) (*ListChainIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListChainIds not implemented")
}
func (*UnimplementedWalletRPCServiceServer) ListKeys(ctx context.Context, req *ListKeysRequest) (*ListKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKeys not implemented")
}
func (*UnimplementedWalletRPCServiceServer) SetOwner(ctx context.Context, req *SetOwnerRequest) (*SetOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOwner not implemented")
}
func (*UnimplementedWalletRPCServiceServer) SetData(ctx context.Context, req *SetDataRequest) (*SetDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetData not implemented")
}
func (*UnimplementedWalletRPCServiceServer) Resolve(ctx context.Context, req *ResolveRequest) (*ResolveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resolve not implemented")
}
func (*UnimplementedWalletRPCServiceServer) ResolveAt(ctx context.Context, req *ResolveAtRequest) (*ResolveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveAt not implemented")
}
func (*UnimplementedWalletRPCServiceServer) EstablishToken(ctx context.Context, req *EstablishTokenRequest) (*EstablishTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstablishToken not implemented")
}
func (*UnimplementedWalletRPCServiceServer) MintToken(ctx context.Context, req *MintTokenRequest) (*MintTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintToken not implemented")
}
func (*UnimplementedWalletRPCServiceServer) SendToken(ctx context.Context, req *SendTokenRequest) (*SendTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendToken not implemented")
}
func (*UnimplementedWalletRPCServiceServer) ReceiveToken(ctx context.Context, req *ReceiveTokenRequest) (*ReceiveTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveToken not implemented")
}
func (*UnimplementedWalletRPCServiceServer) PlayTransactions(ctx context.Context, req *PlayTransactionsRequest) (*PlayTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlayTransactions not implemented")
}

func RegisterWalletRPCServiceServer(s *grpc.Server, srv WalletRPCServiceServer) {
	s.RegisterService(&_WalletRPCService_serviceDesc, srv)
}

func _WalletRPCService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).Register(ctx, req.(*RegisterWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_GenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).GenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/GenerateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).GenerateKey(ctx, req.(*GenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_CreateChainTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).CreateChainTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/CreateChainTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).CreateChainTree(ctx, req.(*GenerateChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_ExportChainTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).ExportChainTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/ExportChainTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).ExportChainTree(ctx, req.(*ExportChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_ImportChainTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).ImportChainTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/ImportChainTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).ImportChainTree(ctx, req.(*ImportChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_GetTip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).GetTip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/GetTip",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).GetTip(ctx, req.(*GetTipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_ListChainIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChainIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).ListChainIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/ListChainIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).ListChainIds(ctx, req.(*ListChainIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).ListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/ListKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).ListKeys(ctx, req.(*ListKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_SetOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).SetOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/SetOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).SetOwner(ctx, req.(*SetOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_SetData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).SetData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/SetData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).SetData(ctx, req.(*SetDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_Resolve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).Resolve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/Resolve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).Resolve(ctx, req.(*ResolveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_ResolveAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).ResolveAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/ResolveAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).ResolveAt(ctx, req.(*ResolveAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_EstablishToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstablishTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).EstablishToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/EstablishToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).EstablishToken(ctx, req.(*EstablishTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_MintToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MintTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).MintToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/MintToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).MintToken(ctx, req.(*MintTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_SendToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).SendToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/SendToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).SendToken(ctx, req.(*SendTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_ReceiveToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).ReceiveToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/ReceiveToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).ReceiveToken(ctx, req.(*ReceiveTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletRPCService_PlayTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletRPCServiceServer).PlayTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1services.WalletRPCService/PlayTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletRPCServiceServer).PlayTransactions(ctx, req.(*PlayTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WalletRPCService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1services.WalletRPCService",
	HandlerType: (*WalletRPCServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _WalletRPCService_Register_Handler,
		},
		{
			MethodName: "GenerateKey",
			Handler:    _WalletRPCService_GenerateKey_Handler,
		},
		{
			MethodName: "CreateChainTree",
			Handler:    _WalletRPCService_CreateChainTree_Handler,
		},
		{
			MethodName: "ExportChainTree",
			Handler:    _WalletRPCService_ExportChainTree_Handler,
		},
		{
			MethodName: "ImportChainTree",
			Handler:    _WalletRPCService_ImportChainTree_Handler,
		},
		{
			MethodName: "GetTip",
			Handler:    _WalletRPCService_GetTip_Handler,
		},
		{
			MethodName: "ListChainIds",
			Handler:    _WalletRPCService_ListChainIds_Handler,
		},
		{
			MethodName: "ListKeys",
			Handler:    _WalletRPCService_ListKeys_Handler,
		},
		{
			MethodName: "SetOwner",
			Handler:    _WalletRPCService_SetOwner_Handler,
		},
		{
			MethodName: "SetData",
			Handler:    _WalletRPCService_SetData_Handler,
		},
		{
			MethodName: "Resolve",
			Handler:    _WalletRPCService_Resolve_Handler,
		},
		{
			MethodName: "ResolveAt",
			Handler:    _WalletRPCService_ResolveAt_Handler,
		},
		{
			MethodName: "EstablishToken",
			Handler:    _WalletRPCService_EstablishToken_Handler,
		},
		{
			MethodName: "MintToken",
			Handler:    _WalletRPCService_MintToken_Handler,
		},
		{
			MethodName: "SendToken",
			Handler:    _WalletRPCService_SendToken_Handler,
		},
		{
			MethodName: "ReceiveToken",
			Handler:    _WalletRPCService_ReceiveToken_Handler,
		},
		{
			MethodName: "PlayTransactions",
			Handler:    _WalletRPCService_PlayTransactions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/services.proto",
}

func (m *AddBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		for iNdEx := len(m.State) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.State[iNdEx])
			copy(dAtA[i:], m.State[iNdEx])
			i = encodeVarintServices(dAtA, i, uint64(len(m.State[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewTip) > 0 {
		i -= len(m.NewTip)
		copy(dAtA[i:], m.NewTip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.NewTip)))
		i--
		dAtA[i] = 0x22
	}
	if m.Height != 0 {
		i = encodeVarintServices(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PreviousTip) > 0 {
		i -= len(m.PreviousTip)
		copy(dAtA[i:], m.PreviousTip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.PreviousTip)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ObjectId) > 0 {
		i -= len(m.ObjectId)
		copy(dAtA[i:], m.ObjectId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ObjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReceiveCurrentStateSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveCurrentStateSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReceiveCurrentStateSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestCurrentStateSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestCurrentStateSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestCurrentStateSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Ping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Credentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Credentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Credentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PassPhrase) > 0 {
		i -= len(m.PassPhrase)
		copy(dAtA[i:], m.PassPhrase)
		i = encodeVarintServices(dAtA, i, uint64(len(m.PassPhrase)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WalletName) > 0 {
		i -= len(m.WalletName)
		copy(dAtA[i:], m.WalletName)
		i = encodeVarintServices(dAtA, i, uint64(len(m.WalletName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SerializableChainTree) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SerializableChainTree) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SerializableChainTree) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Signatures) > 0 {
		for k := range m.Signatures {
			v := m.Signatures[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServices(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintServices(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintServices(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Dag) > 0 {
		for iNdEx := len(m.Dag) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dag[iNdEx])
			copy(dAtA[i:], m.Dag[iNdEx])
			i = encodeVarintServices(dAtA, i, uint64(len(m.Dag[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RegisterWalletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterWalletRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterWalletRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterWalletResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterWalletResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterWalletResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WalletName) > 0 {
		i -= len(m.WalletName)
		copy(dAtA[i:], m.WalletName)
		i = encodeVarintServices(dAtA, i, uint64(len(m.WalletName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageAdapterConfigForBadger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageAdapterConfigForBadger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageAdapterConfigForBadger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageAdapterConfigForIpld) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageAdapterConfigForIpld) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageAdapterConfigForIpld) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Offline {
		i--
		if m.Offline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageAdapterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageAdapterConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageAdapterConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdapterConfig != nil {
		{
			size := m.AdapterConfig.Size()
			i -= size
			if _, err := m.AdapterConfig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StorageAdapterConfig_Badger) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *StorageAdapterConfig_Badger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Badger != nil {
		{
			size, err := m.Badger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StorageAdapterConfig_Ipld) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *StorageAdapterConfig_Ipld) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipld != nil {
		{
			size, err := m.Ipld.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GenerateChainRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateChainRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateChainRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageAdapter != nil {
		{
			size, err := m.StorageAdapter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyAddr) > 0 {
		i -= len(m.KeyAddr)
		copy(dAtA[i:], m.KeyAddr)
		i = encodeVarintServices(dAtA, i, uint64(len(m.KeyAddr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenerateChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateChainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateChainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportChainRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportChainRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportChainRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportChainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportChainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainTree) > 0 {
		i -= len(m.ChainTree)
		copy(dAtA[i:], m.ChainTree)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainTree)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImportChainRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportChainRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportChainRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipValidation {
		i--
		if m.SkipValidation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.StorageAdapter != nil {
		{
			size, err := m.StorageAdapter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChainTree) > 0 {
		i -= len(m.ChainTree)
		copy(dAtA[i:], m.ChainTree)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainTree)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImportChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportChainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportChainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenerateKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenerateKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyAddr) > 0 {
		i -= len(m.KeyAddr)
		copy(dAtA[i:], m.KeyAddr)
		i = encodeVarintServices(dAtA, i, uint64(len(m.KeyAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTipRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTipRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTipRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTipResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTipResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTipResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListChainIdsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListChainIdsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListChainIdsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListChainIdsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListChainIdsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListChainIdsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainIds) > 0 {
		for iNdEx := len(m.ChainIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChainIds[iNdEx])
			copy(dAtA[i:], m.ChainIds[iNdEx])
			i = encodeVarintServices(dAtA, i, uint64(len(m.ChainIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListKeysResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKeysResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKeysResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyAddrs) > 0 {
		for iNdEx := len(m.KeyAddrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyAddrs[iNdEx])
			copy(dAtA[i:], m.KeyAddrs[iNdEx])
			i = encodeVarintServices(dAtA, i, uint64(len(m.KeyAddrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetOwnerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetOwnerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetOwnerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyAddr) > 0 {
		i -= len(m.KeyAddr)
		copy(dAtA[i:], m.KeyAddr)
		i = encodeVarintServices(dAtA, i, uint64(len(m.KeyAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetOwnerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetOwnerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetOwnerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.KeyAddr) > 0 {
		i -= len(m.KeyAddr)
		copy(dAtA[i:], m.KeyAddr)
		i = encodeVarintServices(dAtA, i, uint64(len(m.KeyAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResolveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResolveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RemainingPath) > 0 {
		i -= len(m.RemainingPath)
		copy(dAtA[i:], m.RemainingPath)
		i = encodeVarintServices(dAtA, i, uint64(len(m.RemainingPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResolveAtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveAtRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveAtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EstablishTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstablishTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstablishTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.KeyAddr) > 0 {
		i -= len(m.KeyAddr)
		copy(dAtA[i:], m.KeyAddr)
		i = encodeVarintServices(dAtA, i, uint64(len(m.KeyAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EstablishTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstablishTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstablishTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MintTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MintTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MintTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.KeyAddr) > 0 {
		i -= len(m.KeyAddr)
		copy(dAtA[i:], m.KeyAddr)
		i = encodeVarintServices(dAtA, i, uint64(len(m.KeyAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MintTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MintTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MintTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Amount != 0 {
		i = encodeVarintServices(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DestinationChainId) > 0 {
		i -= len(m.DestinationChainId)
		copy(dAtA[i:], m.DestinationChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.DestinationChainId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TokenName) > 0 {
		i -= len(m.TokenName)
		copy(dAtA[i:], m.TokenName)
		i = encodeVarintServices(dAtA, i, uint64(len(m.TokenName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeyAddr) > 0 {
		i -= len(m.KeyAddr)
		copy(dAtA[i:], m.KeyAddr)
		i = encodeVarintServices(dAtA, i, uint64(len(m.KeyAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SendToken) > 0 {
		i -= len(m.SendToken)
		copy(dAtA[i:], m.SendToken)
		i = encodeVarintServices(dAtA, i, uint64(len(m.SendToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReceiveTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReceiveTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenPayload) > 0 {
		i -= len(m.TokenPayload)
		copy(dAtA[i:], m.TokenPayload)
		i = encodeVarintServices(dAtA, i, uint64(len(m.TokenPayload)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeyAddr) > 0 {
		i -= len(m.KeyAddr)
		copy(dAtA[i:], m.KeyAddr)
		i = encodeVarintServices(dAtA, i, uint64(len(m.KeyAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReceiveTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReceiveTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTokenBalanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenBalanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTokenBalanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenName) > 0 {
		i -= len(m.TokenName)
		copy(dAtA[i:], m.TokenName)
		i = encodeVarintServices(dAtA, i, uint64(len(m.TokenName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTokenBalanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenBalanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTokenBalanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintServices(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayTransactionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayTransactionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayTransactionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for iNdEx := len(m.Transactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServices(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.KeyAddr) > 0 {
		i -= len(m.KeyAddr)
		copy(dAtA[i:], m.KeyAddr)
		i = encodeVarintServices(dAtA, i, uint64(len(m.KeyAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintServices(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayTransactionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayTransactionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayTransactionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tip) > 0 {
		i -= len(m.Tip)
		copy(dAtA[i:], m.Tip)
		i = encodeVarintServices(dAtA, i, uint64(len(m.Tip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintServices(dAtA []byte, offset int, v uint64) int {
	offset -= sovServices(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AddBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ObjectId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.PreviousTip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovServices(uint64(m.Height))
	}
	l = len(m.NewTip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if len(m.State) > 0 {
		for _, b := range m.State {
			l = len(b)
			n += 1 + l + sovServices(uint64(l))
		}
	}
	return n
}

func (m *ReceiveCurrentStateSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *RequestCurrentStateSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Ping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *Pong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *Credentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WalletName)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.PassPhrase)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *SerializableChainTree) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dag) > 0 {
		for _, b := range m.Dag {
			l = len(b)
			n += 1 + l + sovServices(uint64(l))
		}
	}
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServices(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovServices(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovServices(uint64(mapEntrySize))
		}
	}
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *RegisterWalletRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *RegisterWalletResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WalletName)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *StorageAdapterConfigForBadger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *StorageAdapterConfigForIpld) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if m.Offline {
		n += 2
	}
	return n
}

func (m *StorageAdapterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdapterConfig != nil {
		n += m.AdapterConfig.Size()
	}
	return n
}

func (m *StorageAdapterConfig_Badger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Badger != nil {
		l = m.Badger.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}
func (m *StorageAdapterConfig_Ipld) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipld != nil {
		l = m.Ipld.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}
func (m *GenerateChainRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.KeyAddr)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if m.StorageAdapter != nil {
		l = m.StorageAdapter.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *GenerateChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ExportChainRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ExportChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainTree)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ImportChainRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainTree)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if m.StorageAdapter != nil {
		l = m.StorageAdapter.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	if m.SkipValidation {
		n += 2
	}
	return n
}

func (m *ImportChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *GenerateKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *GenerateKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyAddr)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *GetTipRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *GetTipResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ListChainIdsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ListChainIdsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChainIds) > 0 {
		for _, s := range m.ChainIds {
			l = len(s)
			n += 1 + l + sovServices(uint64(l))
		}
	}
	return n
}

func (m *ListKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ListKeysResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KeyAddrs) > 0 {
		for _, s := range m.KeyAddrs {
			l = len(s)
			n += 1 + l + sovServices(uint64(l))
		}
	}
	return n
}

func (m *SetOwnerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.KeyAddr)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *SetOwnerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *SetDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.KeyAddr)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *SetDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ResolveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ResolveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RemainingPath)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ResolveAtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *EstablishTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.KeyAddr)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *EstablishTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *MintTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.KeyAddr)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *MintTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *SendTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.KeyAddr)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.TokenName)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.DestinationChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovServices(uint64(m.Amount))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *SendTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SendToken)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ReceiveTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.KeyAddr)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.TokenPayload)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *ReceiveTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *GetTokenBalanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.TokenName)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func (m *GetTokenBalanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != 0 {
		n += 1 + sovServices(uint64(m.Amount))
	}
	return n
}

func (m *PlayTransactionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	l = len(m.KeyAddr)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovServices(uint64(l))
		}
	}
	return n
}

func (m *PlayTransactionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tip)
	if l > 0 {
		n += 1 + l + sovServices(uint64(l))
	}
	return n
}

func sovServices(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozServices(x uint64) (n int) {
	return sovServices(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectId = append(m.ObjectId[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjectId == nil {
				m.ObjectId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousTip", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousTip = append(m.PreviousTip[:0], dAtA[iNdEx:postIndex]...)
			if m.PreviousTip == nil {
				m.PreviousTip = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTip", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewTip = append(m.NewTip[:0], dAtA[iNdEx:postIndex]...)
			if m.NewTip == nil {
				m.NewTip = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State, make([]byte, postIndex-iNdEx))
			copy(m.State[len(m.State)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveCurrentStateSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveCurrentStateSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveCurrentStateSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestCurrentStateSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestCurrentStateSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestCurrentStateSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Credentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Credentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Credentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassPhrase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PassPhrase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SerializableChainTree) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SerializableChainTree: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SerializableChainTree: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dag = append(m.Dag, make([]byte, postIndex-iNdEx))
			copy(m.Dag[len(m.Dag)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signatures == nil {
				m.Signatures = make(map[string]*signatures.Signature)
			}
			var mapkey string
			var mapvalue *signatures.Signature
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServices
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServices
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthServices
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthServices
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServices
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServices
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServices
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &signatures.Signature{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServices(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServices
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterWalletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterWalletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterWalletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterWalletResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterWalletResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterWalletResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageAdapterConfigForBadger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageAdapterConfigForBadger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageAdapterConfigForBadger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageAdapterConfigForIpld) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageAdapterConfigForIpld: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageAdapterConfigForIpld: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Offline = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageAdapterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageAdapterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageAdapterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageAdapterConfigForBadger{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdapterConfig = &StorageAdapterConfig_Badger{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipld", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageAdapterConfigForIpld{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdapterConfig = &StorageAdapterConfig_Ipld{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateChainRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateChainRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateChainRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageAdapter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageAdapter == nil {
				m.StorageAdapter = &StorageAdapterConfig{}
			}
			if err := m.StorageAdapter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportChainRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportChainRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportChainRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainTree", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainTree = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportChainRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportChainRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportChainRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainTree", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainTree = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageAdapter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageAdapter == nil {
				m.StorageAdapter = &StorageAdapterConfig{}
			}
			if err := m.StorageAdapter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipValidation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipValidation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTipRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTipRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTipRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTipResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTipResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTipResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListChainIdsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListChainIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListChainIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListChainIdsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListChainIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListChainIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainIds = append(m.ChainIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListKeysResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKeysResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKeysResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAddrs = append(m.KeyAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetOwnerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetOwnerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetOwnerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &transactions.SetOwnershipPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetOwnerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetOwnerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetOwnerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &transactions.SetDataPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemainingPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveAtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveAtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveAtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstablishTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstablishTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstablishTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &transactions.EstablishTokenPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstablishTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstablishTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstablishTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MintTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MintTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MintTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &transactions.MintTokenPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MintTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MintTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MintTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &transactions.SendTokenPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SendToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenPayload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenPayload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenBalanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenBalanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenBalanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenBalanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenBalanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenBalanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayTransactionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayTransactionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayTransactionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &Credentials{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &transactions.Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayTransactionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayTransactionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayTransactionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipServices(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowServices
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServices
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServices
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthServices
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthServices
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowServices
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipServices(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthServices
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthServices = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowServices   = fmt.Errorf("proto: integer overflow")
)
